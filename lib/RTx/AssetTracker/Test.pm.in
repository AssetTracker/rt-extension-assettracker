use strict;
use warnings;

### after: use lib qw(@RT_LIB_PATH@);
use lib qw(/opt/rt3/local/lib /opt/rt3/lib);

package RTx::AssetTracker::Test;

our @ISA;
BEGIN {
    local $@;
    eval { require RT::Test; 1 } or do {
        require Test::More;
        Test::More::BAIL_OUT(
            "requires 3.8 to run tests. Error:\n$@\n"
            ."You may need to set PERL5LIB=/path/to/rt/lib"
        );
    };
    push @ISA, 'RT::Test';
}

sub import {
    my $class = shift;
    my %args  = @_;

    $args{'requires'} ||= [];
    if ( $args{'testing'} ) {
        unshift @{ $args{'requires'} }, 'RTx::AssetTracker';
    } else {
        $args{'testing'} = 'RTx::AssetTracker';
    }

    $class->SUPER::import( %args );

    RT->Config->LoadConfig( File => 'AT_Config.pm' );
    require RTx::AssetTracker;
}

=head2 load_or_create_type

=cut

sub load_or_create_type {
    my $self = shift;
    my %args = ( Disabled => 0, @_ );
    my $obj = RTx::AssetTracker::Type->new( RT->SystemUser );
    if ( $args{'Name'} ) {
        $obj->LoadByCols( Name => $args{'Name'} );
    } else {
        die "Name is required";
    }
    unless ( $obj->id ) {
        my ($val, $msg) = $obj->Create( %args );
        die "$msg" unless $val;
    }

    return $obj;
}

sub delete_type_watchers {
    my $self = shift;
    my @types = @_;

    foreach my $q ( @types ) {
        foreach my $t ( RTx::AssetTracker::Type->RoleGroupTypes ) {
            $q->DeleteWatcher( Type => $t, PrincipalId => $_->MemberId )
                foreach @{ $q->$t()->MembersObj->ItemsArrayRef };
        }
    }
}

sub create_assets {
    local $Test::Builder::Level = $Test::Builder::Level + 1;

    my $self = shift;
    my $defaults = shift;
    my @data = @_;
    @data = sort { rand(100) <=> rand(100) } @data
        if delete $defaults->{'RandomOrder'};

    $defaults->{'Type'} ||= 'Servers';

    my @res = ();
    my $i = 0;
    while ( @data ) {
        my %args = %{ shift @data };
        $args{$_} = $res[ $args{$_} ]->id foreach
            grep $args{ $_ }, keys %RT::Link::TYPEMAP;
        $args{'Name'} ||= $defaults->{'Type'} . " asset #" . ++$i;
        push @res, $self->create_asset( %$defaults, %args );
    }
    return @res;
}

sub create_asset {
    local $Test::Builder::Level = $Test::Builder::Level + 1;

    my $self = shift;
    my %args = @_;

    unless ( $args{'Name'} ) {
        die "Name is required";
    }
    if ($args{Type} && $args{Type} =~ /\D/) {
        my $type = RTx::AssetTracker::Type->new(RT->SystemUser);
        if (my $id = $type->Load($args{Type}) ) {
            $args{Type} = $id;
        } else {
            die ("Error: Invalid type $args{Type}");
        }
    }

    my $asset = RTx::AssetTracker::Asset->new( RT->SystemUser );
    my ( $id, undef, $msg ) = $asset->Create( %args );
    Test::More::ok( $id, "asset created" )
        or Test::More::diag("error: $msg");

    # hackish, but simpler
    if ( $args{'LastUpdatedBy'} ) {
        $asset->__Set( Field => 'LastUpdatedBy', Value => $args{'LastUpdatedBy'} );
    }


    for my $field ( keys %args ) {
        #TODO check links and watchers

        if ( $field =~ /CustomField-(\d+)/ ) {
            my $cf = $1;
            my $got = join ',', sort map $_->Content,
                @{ $asset->CustomFieldValues($cf)->ItemsArrayRef };
            my $expected = ref $args{$field}
                ? join( ',', sort @{ $args{$field} } )
                : $args{$field};
            Test::More::is( $got, $expected, 'correct CF values' );
        }
        else {
            next if ref $args{$field};
            next unless $asset->can($field) or $asset->_Accessible($field,"read");
            next if ref $asset->$field();
            Test::More::is( $asset->$field(), $args{$field}, "$field is correct" );
        }
    }

    return $asset;
}

sub delete_assets {
    my $self = shift;
    my $query = shift;
    my $assets = RTx::AssetTracker::Assets->new( RT->SystemUser );
    if ( $query ) {
        $assets->FromSQL( $query );
    }
    else {
        $assets->UnLimit;
    }
    while ( my $asset = $assets->Next ) {
        $asset->Delete;
    }
}

sub add_rights {
    my $self = shift;
    my @list = ref $_[0]? @_: @_? { @_ }: ();

    require RT::ACL;
    foreach my $e (@list) {
        my $principal = delete $e->{'Principal'};
        unless ( ref $principal ) {
            if ( $principal =~ /^(everyone|(?:un)?privileged)$/i ) {
                $principal = RT::Group->new( RT->SystemUser );
                $principal->LoadSystemInternalGroup($1);
            } elsif ( my @princ = grep { $_ eq $principal } RTx::AssetTracker::Type->RoleGroupTypes ) {
                $principal = RT::Group->new( RT->SystemUser );
                $principal->LoadByCols(
                    Domain => (ref($e->{'Object'})||'RT::System').'-Role',
                    Type => $princ[0],
                    ref($e->{'Object'})? (Instance => $e->{'Object'}->id): (),
                );
            } else {
                die "principal is not an object, but also is not name of a system group";
            }
        }
        unless ( $principal->isa('RT::Principal') ) {
            if ( $principal->can('PrincipalObj') ) {
                $principal = $principal->PrincipalObj;
            }
        }
        my @rights = ref $e->{'Right'}? @{ $e->{'Right'} }: ($e->{'Right'});
        foreach my $right ( @rights ) {
            my ($status, $msg) = $principal->GrantRight( %$e, Right => $right );
            $RT::Logger->debug($msg);
        }
    }
    return 1;
}

=head2 object_scrips_are

Takes an L<RTx::AssetTracker::Scrip> object or ID as the first argument and an arrayref of
L<RTx::AssetTracker::Type> objects and/or Type IDs as the second argument.

The scrip's applications (L<RTx::AssetTracker::ObjectScrip> records) are tested to ensure they
exactly match the arrayref.

An optional third arrayref may be passed to enumerate and test the asset types the
scrip is B<not> added to.  This is most useful for testing the API returns the
correct results.

=cut

sub object_scrips_are {
    local $Test::Builder::Level = $Test::Builder::Level + 1;
    my $self    = shift;
    my $scrip   = shift;
    my $to      = shift || [];
    my $not_to  = shift;

    unless (blessed($scrip)) {
        my $id = $scrip;
        $scrip = RTx::AssetTracker::Scrip->new( RT->SystemUser );
        $scrip->Load($id);
    }

    $to = [ map { blessed($_) ? $_->id : $_ } @$to ];
    Test::More::ok($scrip->IsAdded($_), "added to asset type $_" ) foreach @$to;
    Test::More::is_deeply(
        [sort map $_->id, @{ $scrip->AddedTo->ItemsArrayRef }],
        [sort grep $_, @$to ],
        'correct list of added to asset types',
    );

    if ($not_to) {
        $not_to = [ map { blessed($_) ? $_->id : $_ } @$not_to ];
        Test::More::ok(!$scrip->IsAdded($_), "not added to asset type $_" ) foreach @$not_to;
        Test::More::is_deeply(
            [sort map $_->id, @{ $scrip->NotAddedTo->ItemsArrayRef }],
            [sort grep $_, @$not_to ],
            'correct list of not added to asset types',
        );
    }
}

1;
